'use strict';

var middlewareHostHeader = require('@aws-sdk/middleware-host-header');
var middlewareLogger = require('@aws-sdk/middleware-logger');
var middlewareRecursionDetection = require('@aws-sdk/middleware-recursion-detection');
var middlewareUserAgent = require('@aws-sdk/middleware-user-agent');
var configResolver = require('@smithy/config-resolver');
var core = require('@smithy/core');
var middlewareContentLength = require('@smithy/middleware-content-length');
var middlewareEndpoint = require('@smithy/middleware-endpoint');
var middlewareRetry = require('@smithy/middleware-retry');
var smithyClient = require('@smithy/smithy-client');
var httpAuthSchemeProvider = require('./auth/httpAuthSchemeProvider');
var runtimeConfig = require('./runtimeConfig');
var regionConfigResolver = require('@aws-sdk/region-config-resolver');
var protocolHttp = require('@smithy/protocol-http');
var middlewareSerde = require('@smithy/middleware-serde');
var core$1 = require('@aws-sdk/core');

const resolveClientEndpointParameters = (options) => {
    return Object.assign(options, {
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "polly",
    });
};
const commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};

const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig), smithyClient.getDefaultExtensionConfiguration(runtimeConfig), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration(runtimeConfig));
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
};

class PollyClient extends smithyClient.Client {
    config;
    constructor(...[configuration]) {
        const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
        super(_config_0);
        this.initConfig = _config_0;
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
        const _config_3 = middlewareRetry.resolveRetryConfig(_config_2);
        const _config_4 = configResolver.resolveRegionConfig(_config_3);
        const _config_5 = middlewareHostHeader.resolveHostHeaderConfig(_config_4);
        const _config_6 = middlewareEndpoint.resolveEndpointConfig(_config_5);
        const _config_7 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        this.config = _config_8;
        this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
        this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
        this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
        this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
        this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
        this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
            httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultPollyHttpAuthSchemeParametersProvider,
            identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
            }),
        }));
        this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
    }
    destroy() {
        super.destroy();
    }
}

class PollyServiceException extends smithyClient.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, PollyServiceException.prototype);
    }
}

class LexiconNotFoundException extends PollyServiceException {
    name = "LexiconNotFoundException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "LexiconNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, LexiconNotFoundException.prototype);
    }
}
class ServiceFailureException extends PollyServiceException {
    name = "ServiceFailureException";
    $fault = "server";
    constructor(opts) {
        super({
            name: "ServiceFailureException",
            $fault: "server",
            ...opts,
        });
        Object.setPrototypeOf(this, ServiceFailureException.prototype);
    }
}
const Engine = {
    GENERATIVE: "generative",
    LONG_FORM: "long-form",
    NEURAL: "neural",
    STANDARD: "standard",
};
const LanguageCode = {
    ar_AE: "ar-AE",
    arb: "arb",
    ca_ES: "ca-ES",
    cmn_CN: "cmn-CN",
    cs_CZ: "cs-CZ",
    cy_GB: "cy-GB",
    da_DK: "da-DK",
    de_AT: "de-AT",
    de_CH: "de-CH",
    de_DE: "de-DE",
    en_AU: "en-AU",
    en_GB: "en-GB",
    en_GB_WLS: "en-GB-WLS",
    en_IE: "en-IE",
    en_IN: "en-IN",
    en_NZ: "en-NZ",
    en_SG: "en-SG",
    en_US: "en-US",
    en_ZA: "en-ZA",
    es_ES: "es-ES",
    es_MX: "es-MX",
    es_US: "es-US",
    fi_FI: "fi-FI",
    fr_BE: "fr-BE",
    fr_CA: "fr-CA",
    fr_FR: "fr-FR",
    hi_IN: "hi-IN",
    is_IS: "is-IS",
    it_IT: "it-IT",
    ja_JP: "ja-JP",
    ko_KR: "ko-KR",
    nb_NO: "nb-NO",
    nl_BE: "nl-BE",
    nl_NL: "nl-NL",
    pl_PL: "pl-PL",
    pt_BR: "pt-BR",
    pt_PT: "pt-PT",
    ro_RO: "ro-RO",
    ru_RU: "ru-RU",
    sv_SE: "sv-SE",
    tr_TR: "tr-TR",
    yue_CN: "yue-CN",
};
const Gender = {
    Female: "Female",
    Male: "Male",
};
const VoiceId = {
    Aditi: "Aditi",
    Adriano: "Adriano",
    Amy: "Amy",
    Andres: "Andres",
    Aria: "Aria",
    Arlet: "Arlet",
    Arthur: "Arthur",
    Astrid: "Astrid",
    Ayanda: "Ayanda",
    Bianca: "Bianca",
    Brian: "Brian",
    Burcu: "Burcu",
    Camila: "Camila",
    Carla: "Carla",
    Carmen: "Carmen",
    Celine: "Celine",
    Chantal: "Chantal",
    Conchita: "Conchita",
    Cristiano: "Cristiano",
    Daniel: "Daniel",
    Danielle: "Danielle",
    Dora: "Dora",
    Elin: "Elin",
    Emma: "Emma",
    Enrique: "Enrique",
    Ewa: "Ewa",
    Filiz: "Filiz",
    Gabrielle: "Gabrielle",
    Geraint: "Geraint",
    Giorgio: "Giorgio",
    Gregory: "Gregory",
    Gwyneth: "Gwyneth",
    Hala: "Hala",
    Hannah: "Hannah",
    Hans: "Hans",
    Hiujin: "Hiujin",
    Ida: "Ida",
    Ines: "Ines",
    Isabelle: "Isabelle",
    Ivy: "Ivy",
    Jacek: "Jacek",
    Jan: "Jan",
    Jasmine: "Jasmine",
    Jihye: "Jihye",
    Jitka: "Jitka",
    Joanna: "Joanna",
    Joey: "Joey",
    Justin: "Justin",
    Kajal: "Kajal",
    Karl: "Karl",
    Kazuha: "Kazuha",
    Kendra: "Kendra",
    Kevin: "Kevin",
    Kimberly: "Kimberly",
    Laura: "Laura",
    Lea: "Lea",
    Liam: "Liam",
    Lisa: "Lisa",
    Liv: "Liv",
    Lotte: "Lotte",
    Lucia: "Lucia",
    Lupe: "Lupe",
    Mads: "Mads",
    Maja: "Maja",
    Marlene: "Marlene",
    Mathieu: "Mathieu",
    Matthew: "Matthew",
    Maxim: "Maxim",
    Mia: "Mia",
    Miguel: "Miguel",
    Mizuki: "Mizuki",
    Naja: "Naja",
    Niamh: "Niamh",
    Nicole: "Nicole",
    Ola: "Ola",
    Olivia: "Olivia",
    Pedro: "Pedro",
    Penelope: "Penelope",
    Raveena: "Raveena",
    Remi: "Remi",
    Ricardo: "Ricardo",
    Ruben: "Ruben",
    Russell: "Russell",
    Ruth: "Ruth",
    Sabrina: "Sabrina",
    Salli: "Salli",
    Seoyeon: "Seoyeon",
    Sergio: "Sergio",
    Sofie: "Sofie",
    Stephen: "Stephen",
    Suvi: "Suvi",
    Takumi: "Takumi",
    Tatyana: "Tatyana",
    Thiago: "Thiago",
    Tomoko: "Tomoko",
    Vicki: "Vicki",
    Vitoria: "Vitoria",
    Zayd: "Zayd",
    Zeina: "Zeina",
    Zhiyu: "Zhiyu",
};
class InvalidNextTokenException extends PollyServiceException {
    name = "InvalidNextTokenException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidNextTokenException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidNextTokenException.prototype);
    }
}
class EngineNotSupportedException extends PollyServiceException {
    name = "EngineNotSupportedException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "EngineNotSupportedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, EngineNotSupportedException.prototype);
    }
}
const OutputFormat = {
    JSON: "json",
    MP3: "mp3",
    OGG_OPUS: "ogg_opus",
    OGG_VORBIS: "ogg_vorbis",
    PCM: "pcm",
};
const SpeechMarkType = {
    SENTENCE: "sentence",
    SSML: "ssml",
    VISEME: "viseme",
    WORD: "word",
};
const TaskStatus = {
    COMPLETED: "completed",
    FAILED: "failed",
    IN_PROGRESS: "inProgress",
    SCHEDULED: "scheduled",
};
const TextType = {
    SSML: "ssml",
    TEXT: "text",
};
class InvalidTaskIdException extends PollyServiceException {
    name = "InvalidTaskIdException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidTaskIdException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidTaskIdException.prototype);
    }
}
class SynthesisTaskNotFoundException extends PollyServiceException {
    name = "SynthesisTaskNotFoundException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "SynthesisTaskNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, SynthesisTaskNotFoundException.prototype);
    }
}
class InvalidLexiconException extends PollyServiceException {
    name = "InvalidLexiconException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidLexiconException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidLexiconException.prototype);
    }
}
class InvalidS3BucketException extends PollyServiceException {
    name = "InvalidS3BucketException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidS3BucketException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidS3BucketException.prototype);
    }
}
class InvalidS3KeyException extends PollyServiceException {
    name = "InvalidS3KeyException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidS3KeyException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidS3KeyException.prototype);
    }
}
class InvalidSampleRateException extends PollyServiceException {
    name = "InvalidSampleRateException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidSampleRateException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidSampleRateException.prototype);
    }
}
class InvalidSnsTopicArnException extends PollyServiceException {
    name = "InvalidSnsTopicArnException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidSnsTopicArnException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidSnsTopicArnException.prototype);
    }
}
class InvalidSsmlException extends PollyServiceException {
    name = "InvalidSsmlException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidSsmlException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidSsmlException.prototype);
    }
}
class LanguageNotSupportedException extends PollyServiceException {
    name = "LanguageNotSupportedException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "LanguageNotSupportedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, LanguageNotSupportedException.prototype);
    }
}
class LexiconSizeExceededException extends PollyServiceException {
    name = "LexiconSizeExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "LexiconSizeExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, LexiconSizeExceededException.prototype);
    }
}
class MarksNotSupportedForFormatException extends PollyServiceException {
    name = "MarksNotSupportedForFormatException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "MarksNotSupportedForFormatException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, MarksNotSupportedForFormatException.prototype);
    }
}
class MaxLexemeLengthExceededException extends PollyServiceException {
    name = "MaxLexemeLengthExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "MaxLexemeLengthExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, MaxLexemeLengthExceededException.prototype);
    }
}
class MaxLexiconsNumberExceededException extends PollyServiceException {
    name = "MaxLexiconsNumberExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "MaxLexiconsNumberExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, MaxLexiconsNumberExceededException.prototype);
    }
}
class UnsupportedPlsAlphabetException extends PollyServiceException {
    name = "UnsupportedPlsAlphabetException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "UnsupportedPlsAlphabetException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedPlsAlphabetException.prototype);
    }
}
class UnsupportedPlsLanguageException extends PollyServiceException {
    name = "UnsupportedPlsLanguageException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "UnsupportedPlsLanguageException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedPlsLanguageException.prototype);
    }
}
class SsmlMarksNotSupportedForTextTypeException extends PollyServiceException {
    name = "SsmlMarksNotSupportedForTextTypeException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "SsmlMarksNotSupportedForTextTypeException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, SsmlMarksNotSupportedForTextTypeException.prototype);
    }
}
class TextLengthExceededException extends PollyServiceException {
    name = "TextLengthExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "TextLengthExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, TextLengthExceededException.prototype);
    }
}
const LexiconFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Content && { Content: smithyClient.SENSITIVE_STRING }),
});
const GetLexiconOutputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Lexicon && { Lexicon: LexiconFilterSensitiveLog(obj.Lexicon) }),
});
const PutLexiconInputFilterSensitiveLog = (obj) => ({
    ...obj,
    ...(obj.Content && { Content: smithyClient.SENSITIVE_STRING }),
});
const SynthesizeSpeechOutputFilterSensitiveLog = (obj) => ({
    ...obj,
});

const se_DeleteLexiconCommand = async (input, context) => {
    const b = core.requestBuilder(input, context);
    const headers = {};
    b.bp("/v1/lexicons/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
const se_DescribeVoicesCommand = async (input, context) => {
    const b = core.requestBuilder(input, context);
    const headers = {};
    b.bp("/v1/voices");
    const query = smithyClient.map({
        [_E]: [, input[_E]],
        [_LC]: [, input[_LC]],
        [_IALC]: [() => input.IncludeAdditionalLanguageCodes !== void 0, () => input[_IALC].toString()],
        [_NT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const se_GetLexiconCommand = async (input, context) => {
    const b = core.requestBuilder(input, context);
    const headers = {};
    b.bp("/v1/lexicons/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
const se_GetSpeechSynthesisTaskCommand = async (input, context) => {
    const b = core.requestBuilder(input, context);
    const headers = {};
    b.bp("/v1/synthesisTasks/{TaskId}");
    b.p("TaskId", () => input.TaskId, "{TaskId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
const se_ListLexiconsCommand = async (input, context) => {
    const b = core.requestBuilder(input, context);
    const headers = {};
    b.bp("/v1/lexicons");
    const query = smithyClient.map({
        [_NT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const se_ListSpeechSynthesisTasksCommand = async (input, context) => {
    const b = core.requestBuilder(input, context);
    const headers = {};
    b.bp("/v1/synthesisTasks");
    const query = smithyClient.map({
        [_MR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_NT]: [, input[_NT]],
        [_S]: [, input[_S]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
const se_PutLexiconCommand = async (input, context) => {
    const b = core.requestBuilder(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/lexicons/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = JSON.stringify(smithyClient.take(input, {
        Content: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
const se_StartSpeechSynthesisTaskCommand = async (input, context) => {
    const b = core.requestBuilder(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/synthesisTasks");
    let body;
    body = JSON.stringify(smithyClient.take(input, {
        Engine: [],
        LanguageCode: [],
        LexiconNames: (_) => smithyClient._json(_),
        OutputFormat: [],
        OutputS3BucketName: [],
        OutputS3KeyPrefix: [],
        SampleRate: [],
        SnsTopicArn: [],
        SpeechMarkTypes: (_) => smithyClient._json(_),
        Text: [],
        TextType: [],
        VoiceId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
const se_SynthesizeSpeechCommand = async (input, context) => {
    const b = core.requestBuilder(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/speech");
    let body;
    body = JSON.stringify(smithyClient.take(input, {
        Engine: [],
        LanguageCode: [],
        LexiconNames: (_) => smithyClient._json(_),
        OutputFormat: [],
        SampleRate: [],
        SpeechMarkTypes: (_) => smithyClient._json(_),
        Text: [],
        TextType: [],
        VoiceId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
const de_DeleteLexiconCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = smithyClient.map({
        $metadata: deserializeMetadata(output),
    });
    await smithyClient.collectBody(output.body, context);
    return contents;
};
const de_DescribeVoicesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = smithyClient.map({
        $metadata: deserializeMetadata(output),
    });
    const data = smithyClient.expectNonNull(smithyClient.expectObject(await core$1.parseJsonBody(output.body, context)), "body");
    const doc = smithyClient.take(data, {
        NextToken: smithyClient.expectString,
        Voices: smithyClient._json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetLexiconCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = smithyClient.map({
        $metadata: deserializeMetadata(output),
    });
    const data = smithyClient.expectNonNull(smithyClient.expectObject(await core$1.parseJsonBody(output.body, context)), "body");
    const doc = smithyClient.take(data, {
        Lexicon: smithyClient._json,
        LexiconAttributes: (_) => de_LexiconAttributes(_),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetSpeechSynthesisTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = smithyClient.map({
        $metadata: deserializeMetadata(output),
    });
    const data = smithyClient.expectNonNull(smithyClient.expectObject(await core$1.parseJsonBody(output.body, context)), "body");
    const doc = smithyClient.take(data, {
        SynthesisTask: (_) => de_SynthesisTask(_),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListLexiconsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = smithyClient.map({
        $metadata: deserializeMetadata(output),
    });
    const data = smithyClient.expectNonNull(smithyClient.expectObject(await core$1.parseJsonBody(output.body, context)), "body");
    const doc = smithyClient.take(data, {
        Lexicons: (_) => de_LexiconDescriptionList(_),
        NextToken: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_ListSpeechSynthesisTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = smithyClient.map({
        $metadata: deserializeMetadata(output),
    });
    const data = smithyClient.expectNonNull(smithyClient.expectObject(await core$1.parseJsonBody(output.body, context)), "body");
    const doc = smithyClient.take(data, {
        NextToken: smithyClient.expectString,
        SynthesisTasks: (_) => de_SynthesisTasks(_),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_PutLexiconCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = smithyClient.map({
        $metadata: deserializeMetadata(output),
    });
    await smithyClient.collectBody(output.body, context);
    return contents;
};
const de_StartSpeechSynthesisTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = smithyClient.map({
        $metadata: deserializeMetadata(output),
    });
    const data = smithyClient.expectNonNull(smithyClient.expectObject(await core$1.parseJsonBody(output.body, context)), "body");
    const doc = smithyClient.take(data, {
        SynthesisTask: (_) => de_SynthesisTask(_),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_SynthesizeSpeechCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = smithyClient.map({
        $metadata: deserializeMetadata(output),
        [_CT]: [, output.headers[_ct]],
        [_RC]: [() => void 0 !== output.headers[_xar], () => smithyClient.strictParseInt32(output.headers[_xar])],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.AudioStream = data;
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await core$1.parseJsonErrorBody(output.body, context),
    };
    const errorCode = core$1.loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LexiconNotFoundException":
        case "com.amazonaws.polly#LexiconNotFoundException":
            throw await de_LexiconNotFoundExceptionRes(parsedOutput);
        case "ServiceFailureException":
        case "com.amazonaws.polly#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput);
        case "InvalidNextTokenException":
        case "com.amazonaws.polly#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput);
        case "InvalidTaskIdException":
        case "com.amazonaws.polly#InvalidTaskIdException":
            throw await de_InvalidTaskIdExceptionRes(parsedOutput);
        case "SynthesisTaskNotFoundException":
        case "com.amazonaws.polly#SynthesisTaskNotFoundException":
            throw await de_SynthesisTaskNotFoundExceptionRes(parsedOutput);
        case "InvalidLexiconException":
        case "com.amazonaws.polly#InvalidLexiconException":
            throw await de_InvalidLexiconExceptionRes(parsedOutput);
        case "LexiconSizeExceededException":
        case "com.amazonaws.polly#LexiconSizeExceededException":
            throw await de_LexiconSizeExceededExceptionRes(parsedOutput);
        case "MaxLexemeLengthExceededException":
        case "com.amazonaws.polly#MaxLexemeLengthExceededException":
            throw await de_MaxLexemeLengthExceededExceptionRes(parsedOutput);
        case "MaxLexiconsNumberExceededException":
        case "com.amazonaws.polly#MaxLexiconsNumberExceededException":
            throw await de_MaxLexiconsNumberExceededExceptionRes(parsedOutput);
        case "UnsupportedPlsAlphabetException":
        case "com.amazonaws.polly#UnsupportedPlsAlphabetException":
            throw await de_UnsupportedPlsAlphabetExceptionRes(parsedOutput);
        case "UnsupportedPlsLanguageException":
        case "com.amazonaws.polly#UnsupportedPlsLanguageException":
            throw await de_UnsupportedPlsLanguageExceptionRes(parsedOutput);
        case "EngineNotSupportedException":
        case "com.amazonaws.polly#EngineNotSupportedException":
            throw await de_EngineNotSupportedExceptionRes(parsedOutput);
        case "InvalidS3BucketException":
        case "com.amazonaws.polly#InvalidS3BucketException":
            throw await de_InvalidS3BucketExceptionRes(parsedOutput);
        case "InvalidS3KeyException":
        case "com.amazonaws.polly#InvalidS3KeyException":
            throw await de_InvalidS3KeyExceptionRes(parsedOutput);
        case "InvalidSampleRateException":
        case "com.amazonaws.polly#InvalidSampleRateException":
            throw await de_InvalidSampleRateExceptionRes(parsedOutput);
        case "InvalidSnsTopicArnException":
        case "com.amazonaws.polly#InvalidSnsTopicArnException":
            throw await de_InvalidSnsTopicArnExceptionRes(parsedOutput);
        case "InvalidSsmlException":
        case "com.amazonaws.polly#InvalidSsmlException":
            throw await de_InvalidSsmlExceptionRes(parsedOutput);
        case "LanguageNotSupportedException":
        case "com.amazonaws.polly#LanguageNotSupportedException":
            throw await de_LanguageNotSupportedExceptionRes(parsedOutput);
        case "MarksNotSupportedForFormatException":
        case "com.amazonaws.polly#MarksNotSupportedForFormatException":
            throw await de_MarksNotSupportedForFormatExceptionRes(parsedOutput);
        case "SsmlMarksNotSupportedForTextTypeException":
        case "com.amazonaws.polly#SsmlMarksNotSupportedForTextTypeException":
            throw await de_SsmlMarksNotSupportedForTextTypeExceptionRes(parsedOutput);
        case "TextLengthExceededException":
        case "com.amazonaws.polly#TextLengthExceededException":
            throw await de_TextLengthExceededExceptionRes(parsedOutput);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = smithyClient.withBaseException(PollyServiceException);
const de_EngineNotSupportedExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new EngineNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidLexiconExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidLexiconException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidNextTokenExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidNextTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidS3BucketExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidS3BucketException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidS3KeyExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidS3KeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidSampleRateExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidSampleRateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidSnsTopicArnExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidSnsTopicArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidSsmlExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidSsmlException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidTaskIdExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidTaskIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_LanguageNotSupportedExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new LanguageNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_LexiconNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new LexiconNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_LexiconSizeExceededExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new LexiconSizeExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_MarksNotSupportedForFormatExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new MarksNotSupportedForFormatException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_MaxLexemeLengthExceededExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new MaxLexemeLengthExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_MaxLexiconsNumberExceededExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new MaxLexiconsNumberExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceFailureExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_SsmlMarksNotSupportedForTextTypeExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new SsmlMarksNotSupportedForTextTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_SynthesisTaskNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new SynthesisTaskNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_TextLengthExceededExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new TextLengthExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_UnsupportedPlsAlphabetExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnsupportedPlsAlphabetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_UnsupportedPlsLanguageExceptionRes = async (parsedOutput, context) => {
    const contents = smithyClient.map({});
    const data = parsedOutput.body;
    const doc = smithyClient.take(data, {
        message: smithyClient.expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnsupportedPlsLanguageException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return smithyClient.decorateServiceException(exception, parsedOutput.body);
};
const de_LexiconAttributes = (output, context) => {
    return smithyClient.take(output, {
        Alphabet: smithyClient.expectString,
        LanguageCode: smithyClient.expectString,
        LastModified: (_) => smithyClient.expectNonNull(smithyClient.parseEpochTimestamp(smithyClient.expectNumber(_))),
        LexemesCount: smithyClient.expectInt32,
        LexiconArn: smithyClient.expectString,
        Size: smithyClient.expectInt32,
    });
};
const de_LexiconDescription = (output, context) => {
    return smithyClient.take(output, {
        Attributes: (_) => de_LexiconAttributes(_),
        Name: smithyClient.expectString,
    });
};
const de_LexiconDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LexiconDescription(entry);
    });
    return retVal;
};
const de_SynthesisTask = (output, context) => {
    return smithyClient.take(output, {
        CreationTime: (_) => smithyClient.expectNonNull(smithyClient.parseEpochTimestamp(smithyClient.expectNumber(_))),
        Engine: smithyClient.expectString,
        LanguageCode: smithyClient.expectString,
        LexiconNames: smithyClient._json,
        OutputFormat: smithyClient.expectString,
        OutputUri: smithyClient.expectString,
        RequestCharacters: smithyClient.expectInt32,
        SampleRate: smithyClient.expectString,
        SnsTopicArn: smithyClient.expectString,
        SpeechMarkTypes: smithyClient._json,
        TaskId: smithyClient.expectString,
        TaskStatus: smithyClient.expectString,
        TaskStatusReason: smithyClient.expectString,
        TextType: smithyClient.expectString,
        VoiceId: smithyClient.expectString,
    });
};
const de_SynthesisTasks = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SynthesisTask(entry);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const _CT = "ContentType";
const _E = "Engine";
const _IALC = "IncludeAdditionalLanguageCodes";
const _LC = "LanguageCode";
const _MR = "MaxResults";
const _NT = "NextToken";
const _RC = "RequestCharacters";
const _S = "Status";
const _ct = "content-type";
const _xar = "x-amzn-requestcharacters";

class DeleteLexiconCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [
        middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Parrot_v1", "DeleteLexicon", {})
    .n("PollyClient", "DeleteLexiconCommand")
    .f(void 0, void 0)
    .ser(se_DeleteLexiconCommand)
    .de(de_DeleteLexiconCommand)
    .build() {
}

class DescribeVoicesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [
        middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Parrot_v1", "DescribeVoices", {})
    .n("PollyClient", "DescribeVoicesCommand")
    .f(void 0, void 0)
    .ser(se_DescribeVoicesCommand)
    .de(de_DescribeVoicesCommand)
    .build() {
}

class GetLexiconCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [
        middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Parrot_v1", "GetLexicon", {})
    .n("PollyClient", "GetLexiconCommand")
    .f(void 0, GetLexiconOutputFilterSensitiveLog)
    .ser(se_GetLexiconCommand)
    .de(de_GetLexiconCommand)
    .build() {
}

class GetSpeechSynthesisTaskCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [
        middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Parrot_v1", "GetSpeechSynthesisTask", {})
    .n("PollyClient", "GetSpeechSynthesisTaskCommand")
    .f(void 0, void 0)
    .ser(se_GetSpeechSynthesisTaskCommand)
    .de(de_GetSpeechSynthesisTaskCommand)
    .build() {
}

class ListLexiconsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [
        middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Parrot_v1", "ListLexicons", {})
    .n("PollyClient", "ListLexiconsCommand")
    .f(void 0, void 0)
    .ser(se_ListLexiconsCommand)
    .de(de_ListLexiconsCommand)
    .build() {
}

class ListSpeechSynthesisTasksCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [
        middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Parrot_v1", "ListSpeechSynthesisTasks", {})
    .n("PollyClient", "ListSpeechSynthesisTasksCommand")
    .f(void 0, void 0)
    .ser(se_ListSpeechSynthesisTasksCommand)
    .de(de_ListSpeechSynthesisTasksCommand)
    .build() {
}

class PutLexiconCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [
        middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Parrot_v1", "PutLexicon", {})
    .n("PollyClient", "PutLexiconCommand")
    .f(PutLexiconInputFilterSensitiveLog, void 0)
    .ser(se_PutLexiconCommand)
    .de(de_PutLexiconCommand)
    .build() {
}

class StartSpeechSynthesisTaskCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [
        middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Parrot_v1", "StartSpeechSynthesisTask", {})
    .n("PollyClient", "StartSpeechSynthesisTaskCommand")
    .f(void 0, void 0)
    .ser(se_StartSpeechSynthesisTaskCommand)
    .de(de_StartSpeechSynthesisTaskCommand)
    .build() {
}

class SynthesizeSpeechCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [
        middlewareSerde.getSerdePlugin(config, this.serialize, this.deserialize),
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
    ];
})
    .s("Parrot_v1", "SynthesizeSpeech", {})
    .n("PollyClient", "SynthesizeSpeechCommand")
    .f(void 0, SynthesizeSpeechOutputFilterSensitiveLog)
    .ser(se_SynthesizeSpeechCommand)
    .de(de_SynthesizeSpeechCommand)
    .build() {
}

const commands = {
    DeleteLexiconCommand,
    DescribeVoicesCommand,
    GetLexiconCommand,
    GetSpeechSynthesisTaskCommand,
    ListLexiconsCommand,
    ListSpeechSynthesisTasksCommand,
    PutLexiconCommand,
    StartSpeechSynthesisTaskCommand,
    SynthesizeSpeechCommand,
};
class Polly extends PollyClient {
}
smithyClient.createAggregatedClient(commands, Polly);

const paginateListSpeechSynthesisTasks = core.createPaginator(PollyClient, ListSpeechSynthesisTasksCommand, "NextToken", "NextToken", "MaxResults");

Object.defineProperty(exports, "$Command", {
    enumerable: true,
    get: function () { return smithyClient.Command; }
});
Object.defineProperty(exports, "__Client", {
    enumerable: true,
    get: function () { return smithyClient.Client; }
});
exports.DeleteLexiconCommand = DeleteLexiconCommand;
exports.DescribeVoicesCommand = DescribeVoicesCommand;
exports.Engine = Engine;
exports.EngineNotSupportedException = EngineNotSupportedException;
exports.Gender = Gender;
exports.GetLexiconCommand = GetLexiconCommand;
exports.GetLexiconOutputFilterSensitiveLog = GetLexiconOutputFilterSensitiveLog;
exports.GetSpeechSynthesisTaskCommand = GetSpeechSynthesisTaskCommand;
exports.InvalidLexiconException = InvalidLexiconException;
exports.InvalidNextTokenException = InvalidNextTokenException;
exports.InvalidS3BucketException = InvalidS3BucketException;
exports.InvalidS3KeyException = InvalidS3KeyException;
exports.InvalidSampleRateException = InvalidSampleRateException;
exports.InvalidSnsTopicArnException = InvalidSnsTopicArnException;
exports.InvalidSsmlException = InvalidSsmlException;
exports.InvalidTaskIdException = InvalidTaskIdException;
exports.LanguageCode = LanguageCode;
exports.LanguageNotSupportedException = LanguageNotSupportedException;
exports.LexiconFilterSensitiveLog = LexiconFilterSensitiveLog;
exports.LexiconNotFoundException = LexiconNotFoundException;
exports.LexiconSizeExceededException = LexiconSizeExceededException;
exports.ListLexiconsCommand = ListLexiconsCommand;
exports.ListSpeechSynthesisTasksCommand = ListSpeechSynthesisTasksCommand;
exports.MarksNotSupportedForFormatException = MarksNotSupportedForFormatException;
exports.MaxLexemeLengthExceededException = MaxLexemeLengthExceededException;
exports.MaxLexiconsNumberExceededException = MaxLexiconsNumberExceededException;
exports.OutputFormat = OutputFormat;
exports.Polly = Polly;
exports.PollyClient = PollyClient;
exports.PollyServiceException = PollyServiceException;
exports.PutLexiconCommand = PutLexiconCommand;
exports.PutLexiconInputFilterSensitiveLog = PutLexiconInputFilterSensitiveLog;
exports.ServiceFailureException = ServiceFailureException;
exports.SpeechMarkType = SpeechMarkType;
exports.SsmlMarksNotSupportedForTextTypeException = SsmlMarksNotSupportedForTextTypeException;
exports.StartSpeechSynthesisTaskCommand = StartSpeechSynthesisTaskCommand;
exports.SynthesisTaskNotFoundException = SynthesisTaskNotFoundException;
exports.SynthesizeSpeechCommand = SynthesizeSpeechCommand;
exports.SynthesizeSpeechOutputFilterSensitiveLog = SynthesizeSpeechOutputFilterSensitiveLog;
exports.TaskStatus = TaskStatus;
exports.TextLengthExceededException = TextLengthExceededException;
exports.TextType = TextType;
exports.UnsupportedPlsAlphabetException = UnsupportedPlsAlphabetException;
exports.UnsupportedPlsLanguageException = UnsupportedPlsLanguageException;
exports.VoiceId = VoiceId;
exports.paginateListSpeechSynthesisTasks = paginateListSpeechSynthesisTasks;
